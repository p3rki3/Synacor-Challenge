from collections import deque
import time
import sys
import helpers

class VMInOut:
    def __init__(self, instr_name):
        self.lines, self.inptr, self.inptr_auto, self.instr_auto = [], 0, 0, []
        self.outline, self.queuedline, self.queuedinstr = [], [], []
        self.codes, self.locs = ["Not found" for _ in range(8)], ["Not found" for _ in range(8)]
        try:
            self.lines = open(instr_name, "r").readlines()  # Read in the input instruction list
            self.queuedinstr.append("Instruction list found and loaded...\n")
        except:
            self.queuedinstr.append("No instruction list found...\n")

    def store_vm_ref(self, vmref):
        self.vmref = vmref

    def print_instr(self, instr):
        self.queuedinstr.append(instr)        

    def get_next_inchar(self):
        if self.inptr_auto < len(self.instr_auto):              # Any input string generated by helpers or continuation of game input we are part way through takes precedence
            self.inptr_auto += 1
            return self.instr_auto[self.inptr_auto-1]
        while True:
            if self.inptr >= len(self.lines):
                return 0
            match self.lines[self.inptr][0]:
                case '#':    # print any comments to the screen but don't forward to the VM
                    self.queuedinstr.append(self.lines[self.inptr][1:])
                    self.inptr += 1
                case '!':    # this is a command for the interpreter
                    self.queuedinstr.append(self.lines[self.inptr])
                    self.handle_cmd()
                    self.inptr += 1
                    return self.get_next_inchar()
                case other:
                    self.inptr_auto = 0
                    self.instr_auto = self.lines[self.inptr]
                    self.inptr += 1
                    return self.get_next_inchar()

    def handle_cmd(self):
        match self.lines[self.inptr][1:].split():
            case ['code', *codes]:
                codeno = int(codes[0]) - 1
                self.codes[codeno] = codes[1]
                self.locs[codeno] = codes[2].replace('-', ' ')
            case ['stop']:
                self.inptr = len(self.lines)
            case ['quit']:      # exit this program
                if len(self.vmref.used_ips) > 0:
                    self.vmref.output_used_ips()
                self.vmref.closedown()
            case ['trackip', *onoff]:
                if onoff[0] == "on":
                    self.vmref.usedips = True
                else:
                    self.vmref.usedips = False
            case ['trace', *onoff]:
                if onoff[0] == "on":
                    self.vmref.fulltrace = True
                else:
                    self.vmref.fulltrace = False
            case ['dumpvm']:
                self.vmref.dump_vm()
            case ['slow']:
                self.vmref.slow = True
            case ['fast']:
                self.vmref.slow = False
            case ['solve', *task]:
                if task[0] == "coins":
                    self.print_instr("Running helper function to solve the puzzle of the coins...")
                    self.instr_auto, print_str = helpers.solve_coin_puzzle()
                    self.print_instr(print_str)
                    self.inptr_auto = 0
                elif task[0] == "teleport":
                    self.print_instr("Calculating energy level and fixing up the code to work the teleporter...\n")
                    self.vmref.regs[7], print_str = helpers.calc_energy_level()
                    self.print_instr(print_str)
                    # now bypass the confirm mechanism
                    self.vmref.prog[5489] = self.vmref.prog[5490] = 21    # noop out this instruction
                    self.vmref.prog[5495] = 7                       # reverse meaning of the jump test
                elif task[0] == "mirror":
                    self.print_instr(helpers.mirror_me('wOMwOvMWd8wA') + '\n')
            case ['sleep', *delay]:
                time.sleep(int(delay[0]))
            case other:
                print("Command not recognised: ", self.lines[self.inptr])

    def output_chr(self, char):
        self.outline.append(char)
        if char == '\n':
            self.queuedline.append(''.join(char for char in self.outline))
            self.outline = []


class VM:
    def __init__(self, bin_name, inout, test=False, slow=False, usedips=False, trace=False):
        self.prog, self.regs, self.stack, self.used_ips = [], [0] * 8, deque(), []
        self.ip = self.a = self.b = self.c = self.instcount = 0
        self.test, self.slow, self.usedips, self.fulltrace = test, slow, usedips, trace
        self.ops = {0: (self.phalt, 'halt', 0, 0), 1: (self.pset, 'set', 3, 2), 2: (self.ppush, 'push', 2, 1), 3: (self.ppop, 'pop', 2, 1), 4: (self.peq, 'eq', 4, 3), 5: (self.pgt, 'qt', 4, 3), 
                    6: (self.pjmp, 'jmp', 0, 1), 7: (self.pjt, 'jt', 3, 2), 8: (self.pjf, 'jf', 3, 2), 9: (self.padd, 'add', 4, 3), 10: (self.pmult, 'mult', 4, 3), 11: (self.pmod, 'mod', 4, 3), 
                    12: (self.pand, 'and', 4, 3), 13: (self.por, 'or', 4, 3), 14: (self.pnot, 'not', 3, 2), 15: (self.prmem, 'rmem', 3, 2), 16: (self.pwmem, 'wmem', 3, 2), 
                    17: (self.pcall, 'call', 0, 1), 18: (self.pret, 'ret', 0, 0), 19: (self.pout, 'out', 2, 1), 20: (self.pin, 'in', 2, 1), 21: (self.pnoop, 'noop', 1, 0)}
        self.inout = inout
        self.start_vm_flag = 0
        self.tracefile = open("vmtrace.txt", 'w')
        self.tracefile.writelines("Writing to tracefile...\n")
        with open(bin_name, "rb") as fp:        # Read in the binary program for the VM
            code = fp.read(2)
            while code:
                self.prog.append(int.from_bytes(code, byteorder='little', signed=False))
                code = fp.read(2)
        self.inout.queuedline.append("Read in code of length: " + str(len(self.prog)) + " and ready to run the VM...\n")
        for _ in range(len(self.prog), 32768):  # pad to the end of a 15 bit address space
            self.prog.append(0)

    def closedown(self):
        self.inout.queuedline.append("\nExecuted a total of " + str(self.instcount) + " instructions in the VM\n")
        self.tracefile.writelines("\nEnd of tracefile...\n")
        self.tracefile.close()
        

    # Each of the following implements a single instruction in the VM; the instruction pointer, stack, registers and program binary are all in the class namespace
    @staticmethod
    def phalt():
        self.inout.queuedline.append("\n\nEncountered a halt instruction - stopping the VM\n\n")
        exit(0)

    def pset(self):
        self.regs[self.a if self.a < 32768 else self.a-32768] = self.b if self.b < 32768 else self.regs[self.b-32768]

    def ppush(self):
        self.stack.append(self.a if self.a < 32768 else self.regs[self.a-32768])

    def ppop(self):
        try:
            self.regs[self.a if self.a < 32768 else self.a-32768] = self.stack.pop()
        except:
            self.inout.queuedline.append('Stack underflow on pop - exiting...')
            exit(1)

    def peq(self):
        self.regs[self.a if self.a < 32768 else self.a-32768] = 1 if (self.b if self.b < 32768 else self.regs[self.b-32768]) == (self.c if self.c < 32768 else self.regs[self.c-32768]) else 0

    def pgt(self):
        self.regs[self.a if self.a < 32768 else self.a-32768] = 1 if (self.b if self.b < 32768 else self.regs[self.b-32768]) > (self.c if self.c < 32768 else self.regs[self.c-32768]) else 0

    def pjmp(self):
        self.ip = self.a if self.a < 32768 else self.regs[self.a-32768]

    def pjt(self):
        self.ip = self.ip if (self.a if self.a < 32768 else self.regs[self.a-32768]) == 0 else (self.b if self.b < 32768 else self.regs[self.b-32768]) - 3

    def pjf(self):
        self.ip = (self.b if self.b < 32768 else self.regs[self.b-32768]) - 3 if (self.a if self.a < 32768 else self.regs[self.a-32768]) == 0 else self.ip

    def padd(self):
        self.regs[self.a if self.a < 32768 else self.a-32768] = ((self.b if self.b < 32768 else self.regs[self.b-32768]) + (self.c if self.c < 32768 else self.regs[self.c-32768])) % 32768

    def pmult(self):
        self.regs[self.a if self.a < 32768 else self.a-32768] = ((self.b if self.b < 32768 else self.regs[self.b-32768]) * (self.c if self.c < 32768 else self.regs[self.c-32768])) % 32768

    def pmod(self):
        self.regs[self.a if self.a < 32768 else self.a-32768] = ((self.b if self.b < 32768 else self.regs[self.b-32768]) % (self.c if self.c < 32768 else self.regs[self.c-32768]))

    def pand(self):
        self.regs[self.a if self.a < 32768 else self.a-32768] = ((self.b if self.b < 32768 else self.regs[self.b-32768]) & (self.c if self.c < 32768 else self.regs[self.c-32768]))

    def por(self):
        self.regs[self.a if self.a < 32768 else self.a-32768] = ((self.b if self.b < 32768 else self.regs[self.b-32768]) | (self.c if self.c < 32768 else self.regs[self.c-32768]))

    def pnot(self):
        self.regs[self.a if self.a < 32768 else self.a-32768] = 32767 - (self.b if self.b < 32768 else self.regs[self.b-32768])

    def prmem(self):
        self.regs[self.a - 32768] = self.prog[self.b] if self.b < 32768 else self.prog[self.regs[self.b - 32768]]

    def pwmem(self):
        self.prog[self.a if self.a < 32768 else self.regs[self.a-32768]] = self.b if self.b < 32768 else self.regs[self.b-32768]

    def pcall(self):
        self.stack.append(self.ip+2)
        self.ip = self.a if self.a < 32768 else self.regs[self.a-32768]

    def pret(self): 
        if len(self.stack) == 0:   # empty stack = halt
            self.inout.queuedline.append("Stopping program - stack empty on ret")
            exit(0)
        try:
            self.ip = self.stack.pop()
        except:
            self.inout.queuedline.append('Stack underflow on ret - exiting...')
            exit(1)

    def pout(self):
        if self.slow:
            for _ in range(500000):       # slow down our output
                pass
        self.inout.output_chr(chr(self.prog[self.ip+1]) if self.prog[self.ip+1] < 32768 else chr(self.regs[self.prog[self.ip+1]-32768]))

    def pin(self):      # Read from the given instruction list until it is empty, then read from stdin
        while True:
            nxtchr = self.inout.get_next_inchar()
            if self.slow and nxtchr=='\n':
                for _ in range(250000):       # slow down our input
                    pass
            if nxtchr:                                  # Read from the list of commands in preference to accepting user input
                self.inout.output_chr(nxtchr)
                self.regs[self.prog[self.ip+1] - 32768] = ord(nxtchr)
                return

    @staticmethod
    def pnoop():
        return


    def run_vm(self):
        self.inout.queuedline.append("VM Loaded and waiting - press the Run VM button to start...\n")
        while self.start_vm_flag == 0:
            time.sleep(0.1)
        self.inout.queuedline.append("Running the VM now...\n")
        count = 0
        MAX_EXEC = 0    # Used for testing only - sets max number of instructions before aborting; 0 = just keep going
        while self.ip < len(self.prog) and (count < MAX_EXEC or MAX_EXEC == 0):
            count += 1
            if self.usedips and self.ip not in self.used_ips:
                self.used_ips.append(self.ip)

            (op, op2, inc, args), self.a, self.b, self.c = self.ops[self.prog[self.ip]], self.prog[self.ip+1], self.prog[self.ip+2], self.prog[self.ip+3]
            # This whole section allows us to output a disassembly of what is being executed in real time, together with register values
            if self.fulltrace:
                ops = [' ', ' ', ' ']
                if args > 0:
                    for i in range(args):
                        if self.prog[self.ip + i + 1] < 32768:
                            ops[i] = str(self.prog[self.ip + i + 1])
                        elif 32768 <= self.prog[self.ip + i + 1] <= 32775:
                            ops[i] = '[' + str(self.prog[self.ip + i +1] - 32768) + ']'
                        else:
                            ops[i] = 'invalid'
                traceline = '{0: <8}'.format(str(self.ip)) + '{0: <8}'.format(str(self.prog[self.ip])) + '{0: <8}'.format(str(op2)) + '{0: <8}'.format(ops[0]) + '{0: <8}'.format(ops[1]) + '{0: <8}'.format(ops[2]) + str(self.regs) + '\n'
                self.tracefile.writelines(traceline)

            # This is the despatcher - where the real cool n funky magic happens - calling the right function based on a dictionary lookup of the opcode!
            if (self.test and op in [self.phalt, self.pout, self.pnoop]) or self.test == False:
                op()
                self.instcount += 1
            self.ip += inc
            if self.instcount % 100000 == 0:
                time.sleep(0.1)
        self.closedown()
        return

    def output_used_ips(self):
        self.used_ips.sort()
        self.inout.queuedline.append("Writing out a list of used ip addresses for disassembly\n")
        with open('usedips.txt', 'w') as fp:
            fp.write('\n'.join(str(ip) for ip in self.used_ips))
            fp.write('\n')

    def dump_vm(self):
        self.inout.queuedline.append("Dumping the current vm code to disk")
        with open('dumpvm.bin', "wb") as fp:        # Read in the binary program for the VM
            for p in self.prog:
                fp.write(p.to_bytes(2, 'little'))
